# 相似项发现

## 相似项发现

#### 最小哈希技术

最小哈希技术：通过对大集合进行压缩，并且可以基于压缩后的结果推导原始集合的相似度。

#### 集合的jaccard相似度

集合S与集合T的交集和并集大小之间的比率。

​	经过最小哈希技术处理后，两个集合经过随机排列转换之后得到的最小哈希值相等的概率等于这两个集合的jaccard相似度。但是即使可以使用最小哈希将大文档压缩成小的签名并同时保持任意对文档之间的预期相似度，但是高效查找具有最大相似度的文档仍然是不可能的，即使文档数目不大，但是需要比对的文档数目很大。

#### 寻找相似的文档

近似算法：首先找出可能的候选对相似文档集合，然后基于该集合发现真正的相似文档；这种方法可能会产生伪反例，即某些文档对由于没有进入候选所以最终没有被识别出来。该方法也会产生伪正例，即评估了某些相似度后，其相似度不足。

## 距离测度

距离测度应该满足的性质：

非负性、相同距离为0，距离对称性，三角不等式

#### 欧式距离

L2范式：计算每一维上的距离，然后求他们的平方和，最后求算算术平方根。

#### 曼哈顿距离

L1范式：两个点的距离是每维距离的绝对值之和

#### jaccard距离

1减去x y的交集与并集的比率

#### 余弦距离

#### 编辑距离

字符串比较：将字符串x转换为y所需要的单字符插入及删除操作的最小数目。

另一种方式：字符串x和y的最长公共子序列（不要求连续）

编辑距离等于x与y的长度之和减去它们的LCS长度的两倍。

#### 海明距离

两个向量中不同分量的个数

例如10101 和 11110的海明距离是3

## 局部敏感哈希（LHS)

当所能接受的相似度相对较低时，基于LSH的方法表现得最为有效。

#### 面向jaccard距离测度

满足局部敏感哈希的函数族需要满足以下条件：

- 必须更可能选择相似的而不是不相似的作为候选对
- 不同函数之间必须在统计上相互独立，即两个或多个函数的联合概率等于每个函数上独立事件的概率乘积。
- 花费时间必须远低于扫描所有对花费的时间，暴力比较时需要对每个候选对进行计算，而一个哈希函数只需要扫描所有样本，哈希函数的个数远远小于样本数量，所以所有哈希一遍的时间远远小于暴力破解；函数族必须可以组合在一起更好的避免伪正例和反例

设d1<d2是定义在某个距离测度d下的两个距离值。如果一个函数族F中每一个函数f都满足以下条件：

- 如果距离小于d1，则f(x)=f(y)概率至少是p1
- 如果距离大于d2，则f(x)!=f(y)概率至少是p2

则称其为(d1,d2,p1,p2)函数族

​	如果LHS是面向jaccard相似度的，则最小哈希函数族是(D1,D2,1-D1,1-D2),因为jaccard的距离与相似度存在和为1.

​	与构造：假设对(D1,D2,1-D1,1-D2)函数族F，对函数族中所有函数都相等时f(x)=f(y)，新的函数g(x)=g(y)，g是一个(d1,d2,(p1)**r,(p2)**r)的函数族。

​	或构造：假设对(D1,D2,1-D1,1-D2)函数族F，对函数族中所有函数只有有一个满足f(x)=f(y)，则新的函数g(x)=g(y)，g是一个(d1,d2,1-(1-p1)**r,1-(1-p2)**r)的函数族。

​	通过任意次串联与构造和或构造过程中，就可以使得p2接近0，同时p1接近1.



#### 面向其他距离测度的LSH函数族

##### 面向海明距离的LSH函数族

##### 面向余弦距离的LSH函数族

##### 面向欧式距离的LSH函数族

## 局部敏感哈希的应用

##### 实体关联

含义：将代表同一实体（如同一个人）的数据记录彼此关联。

主要问题：记录之间的相似度计算既不是纯粹的集合相似度也不是纯粹的向量相似度。

##### 指纹匹配

##### 相似报道新闻检测

同一篇新闻报道，在不同报纸的网站上可能显得非常不同

## 高相似度

#### 相等项发现

局部敏感哈希主要解决相似项的问题，面对相等项问题，有更好的解决方法，主要思路是只比较两个样本中的一部分，可以是文档的头部，可以是文档中任意一部分。

#### 基于长度过滤

全局排序方法：首先将所有字符串按照长度进行排序，然后将每个字符串s将与其列表中不远处的另一个字符串进行比较

低频符号优先的排序方法：统首先将所有字符串按照低频符号长度进行排序，然后将每个字符串s将与其列表中不远处的另一个字符串进行比较。





## 流式数据挖掘

含义：数据以一个或多个流的方式到来，如果不对数据进行及时处理或者存储，数据将会永远丢失。首先考虑如何从流中抽取有用的样本，以及如何从流中过滤掉大部分不想要的数据。

### 流查询

流查询有固定查询和ad hoc两种方式

#### 固定查询

固定查询：不必保留整个流数据，只需要维护一个概要值，当新的流元素到达时，我们将它与保存的最大值进行比较，并将结果设为两者中的较大值，输出当前最大值作为查询的应答结果。

#### ad hoc查询

对于当前某个或者多个流仅提交一次，并且希望系统能够应答关于流的任意查询。可以通过流中数据抽样，从流中选择一个子集，以便能够对它进行查询并给出统计性上对整个流具有代表性的结果。

关键问题：如何获得代表性的样本

# 流过滤

​	只想接受流中满足某个准则的元祖集合，被接受的元祖以流的方式传递给另一个过程，而其他元祖被忽略。如果选择的准则基于元祖的的某个可计算属性得到，那么选择操作很容易完成。当选择准则中包含集合元素的查找时，问题变得困难，当集合大到内存中无法存放是，需要使用新的过滤技术--布隆过滤。



## 布隆过滤器

- n个位组成的数组，每个位的初始值都为0
- 一系列哈希函数h1,h2,h3,h4...hk组成的集合；每个哈希函数“键”值映射到上述的n个桶（对应于位数组中n个位）。
- m个键值组成的集合s



​	布隆过滤器的目的是让所有键值在S中的流元素通过，而阻挡大部分键值不在S中的流元素；位数组的所有位初始化为0，对S中的每个键值K，利用每个哈希函数进行处理。对于一些哈希函数Hi及S中的键值K，将每个hi(k)对应的位置为1.

​	当键值为K的流元素到达时，检查所有的h1(k)，h2(k)，...hk(k)对应的位是否全部为1，如果是，则允许该元素通过，如果有多位为0，则认为K不在S中，拒绝该元素通过。

## 流中独立元素统计问题

#### FM算法

通过将全集中的元素哈希到一个足够长的位串，就可以对独立元素个数进行统计，位串必须要足够长，以致哈希函数的可能结果数目要大于全集中的元素个数。

基本思想：如果流中看到的不同元素越多，那么我们看到的不同哈希值也会越多。在看到不同哈希值越多的同时，也越可能看到其中有一个值变得“异常”。















# 













